---
layout: post
title:  "Optimization and Exigency"
date:   2019-03-04 20:23:45 +0000
categories: programming 
---
One of the great follies of programmers as a cultural unit is our tendency to see programming as an analogy for all other systems. The level of control software affords is seductive in the power it grants us. The progress of abstraction layers has brought us to a point where it is common to ignore all but the most cursory aspects of hardware, allowing our concerns to live entirely in the textual domain. This is a great relief. As a software developer nothing disturbs me more than having to confront the corporeality of my systems, as I once did when I heard that in order to solve our issue, a network router would have to be loaded on a truck and transported to the data center. It is tempting, modulo an occasional visceral shock, to privilege our lofty position as a sort of god perspective. Our systems, built only of text, are free to be molded to perfection. The friction between the blinding synapse and the tool is practically nil. No greater arena exists for genius to rise and make itself visible.

Perhaps a contradiction is visible in the very description; the limitations of hardware and its stubborn residence in the physical world lurk behind trapdoors waiting to consume those who forget about them. Even so, a programmer is granted amazing freedom to create internally consistent systems, and mastery of all one perceives is hard to ignore. It is hardly surprising, then, that so many in the profession have so much difficulty acknowledging the limits of their expertise in areas beyond their software domains. This extends destructively to areas adjacent to their domain, in which they actively participate. To put a point on it: the race and gender bias of the programming profession is well known. A strain of bootstraps-style libertarianism runs through the culture, declaring that disparities can only be true reflections of deficiencies. Who can blame the programmers? After all, this is the environment in which they operate: the god perspective, the perfect transport of genius to page. A world of *optimization*.

Pernicious nonsense. More avenues of attack on this idea are available than can possibly be chased down. The limitations of programming as an analogy for any other system are plain to anyone whose field of study has extended beyond computers, but let us leave that for another time. Consider the ways in which writing software does reflect the world around it. Our systems, isolated and internally consistent though we may strive to make them, cannot escape their environments. Though we may elide the hardware if we are clever enough, it is impossible to ignore the situations in which the software is written and used. Consider optimization, that great measure of programmer genius. It is shaving cycles off the run time, cutting storage requirements; thinking more broadly, it is improving class design, disambiguating APIs, everything that makes software, in short, perfect. Perfect, of course, for its assigned task. This is generally one of the most enjoyable parts of programming. It is rewarding, it has the satisfaction of things fitting perfectly in place. To discuss it elicits wistful sighs because we know: it is always cut short. Sometimes we cut it short ourselves. The last 1% isn't worth the trouble. It stops being fun. It stops being clear what is better. The friction between design and performance starts to appear. Speed demands greater obfuscation. Choices become ambiguous. We could beat our heads against these problems forever, but we encounter another barrier: *exigency*.

We build systems to be used. Layers of abstraction may exist between our software and any human finger on a button, but it is inevitable that it is invoked eventually due to some human demand. At some point in its development, the software becomes that horrible enemy of optimization: good enough. This phrase rankles us. It offends our sensibilities. It reflects such pedestrian understanding of our genius. Why would someone want it *now* rather than want it *perfect*? But anyone who creates software professionally knows this moment comes, and if we inspect ourselves, we inevitably see ourselves embrace it. Not every problem engenders endless interest. Some simply need to go away. We write the hack, we cheat, we "know" this code will never have to be looked at again. We have all know the progammers who disdain this. We all find them insufferable. (If this programmer is you, I am sorry you had to find out this way.)

Which is all to say, every programmer who approaches tolerable to work with knows the value of exigency and the absurdity of the genius optimization narrative. Even so, many fail to transport this recognition to issues of bias in the profession. Though we see the inefficiencies and even the failures of our own systems every day, we stubbornly maintain that the status quo must accurately model some normative order. Though we make horrendous mistakes and cut corners, deviating from the heavenly path on a regular basis, we cannot see the analogy of our own responses to circumstances to those of others.

I've seen, in my own life, limits on how humble I can easily be. In programming even, I am far from perfect, but it is far easier to admit my failures in this sphere than elsewhere. In programming, I remain an expert regardless. Some of that is, of course, due to the benefit of having almost all of the culture's demographically privileged traits. It is also, I think, because these admissions of failure stay within the realm of my expertise. I *know* I am wrong. I can see why, analyze it, feel in control of the situation, know how to avoid the mistake. Even when someone else points it out, I am well equipped to absorb their insight and make it my own. When a failure extends beyond my expertise (and the realms of programmers' inexpertise are *vast*) it is a moment that calls for a far greater humbleness. When someone's experience is so far from our own, and we have not done the work to understand their experience, it can defy our intuition. This is difficult to accept: that we do not have the tools to take this lesson and make it our own. This is not an ignorance of a detail, but of an entire collection of circumstances and exigencies that have led to this moment. Here, too, I am often challenged to see the human cost of my mistakes, to confront the indiginity of my indifference. I can only strive to accept this, make amends, and learn from the challenge. A person cannot learn without challenge, and that is, after all, all I am.
