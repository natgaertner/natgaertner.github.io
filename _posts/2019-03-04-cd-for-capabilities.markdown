---
layout: post
title:  "Continuous Deplivery of Capabilities"
date:   2019-03-04 20:43:45 +0000
categories: dev_ops
---
The benefits of a frequent small release model, as opposed to an infrequent large release model, are well established among software development theorists. Incremental release of features allows each change to be more easily vetted for issues before reaching production and more easily diagnosed once issues do appear. Deploying to production ceases to be a disruptive event and becomes commonplace. CD recognizes that the comprehensibility of software is rapidly reduced as it grows in size, and correspondingly, the comprehensibility of software changes follows a similar pattern. Though we can chase perfection through more and more rigorous evaluation processes and rule sets, when the inevitable failure comes, it is better for it to appear in a small change than a big one. Though over time the rate of change of our software may be similar whether we deploy many small changes or few large changes, if the maximum instantaneous rate of change is kept low, the scope of damage that may be done at once is probabilistically kept low as well, and we spend more time "at risk" of gaining information from our changes being exercised in their production venue.

This is all well established and generally accepted software dogma at companies with mature DevOps cultures. But as a builder of DevOps tools, I see a disturbing failure to extend this understanding to the capabilities provided to developers. Increasingly, the same risk aversion that drives fear of deployment: fear of the unknown, a distrust in the correctness of the overall system, offsetting this fear with attempts to exert more perfect control over the system via reactive monitoring and restriction; seems to manifest as a fear of the developer population itself. This fear leads to mandates to restrict the power placed in the hands of developers. Tools which would expand developer capabilities by abstracting away processes are considered suspect and are subject to demands for proof that the new abstraction precisely recreates the restrictions of the old process. Once created, new capabilities are reigned in by demands of full maturity before the developer population can be trusted with them. Where incremental delivery is asked for, it is an incremental delivery of capability with a full delivery of restriction and Foucauldian surveilance.

The developer population is, of course, an unruly set of individual actors well deserving of askance looks, but they are also the only source of systemic improvement in a world where success is definitively measured by "produces good software" (let us assume for a blissful moment that all other systemic problems with the human environment of professional programming are resolved.) By cowering at the unknown and living in fear of pathological habits, we lose the game. Uncertainty has been (ostensibly) defeated, but the victory is Pyrric. All potential for emergent imagination and iterative improvement has been lost. As developers, we think of a new abstraction as creating a new surface upon which to build. When we develop an abstraction, it is only useful insomuch as it is comprehensible to others besides ourselves. We not only free the next generation of *our* product's developers from the tyrrany of our old details, we free *other* developers from those details as well. Without this fundamental tool, cooperative development is impossible. Unless the capabilities can be developed and presented first, before the restrictions are created, the best practices enforced (and yes let us acknowledge the absurdity of declaring best practices for a system upon which no one has been able to practice), we are shuffled into a serialized process dragging out into a bleak infinity.

This is distinct from the imperative to develop Minimum Viable Products (MVPs) and then (if you're lucky) iterate on them. MVP most often implies delivering the most minimal feature set one can build and still declare a "product." Any subsequent iteration is still left in the hands of the original developers. Rarely is there any focus on delivering something on which users can build. When I talk about delivering incremental capability, what I mean is delivering the *most fundamental* feature as soon as possible, rather than the minimum product. A fundamental feature is not necessarily a complete product. It is the component of a product that enables the most capability for the most people. It is supporting new logical primitives, it is enabling behaviors and constructs that were previously impossible. This is not a call to ignore user experience, as a tool which is powerful but difficult to use inevitably attenuates some of its power by restricting access through poor accessibility. Rather it is a call to enable as much as possible, including powerful UX, before attenuating that power ourselves. High opinions of our own capabilities though we may have, surely we do not suffer from such poverty of imagination as to assume that we can have even a small minority of the useful ideas ourselves. Further, how can we evince such stunning lack of empathy as to declare ourselves arbiters over people's needs for their individual situations? The cynical answer is that as a large company we are no longer interested in fostering a variety of individual situations, but it would take a fool to claim that heterogenaity can be eliminated, and perhaps less of a fool, but still no one who should be in charge of developer tools, to declare that we can attack heterogenaity without declaring ourselves the angels of stultification.
